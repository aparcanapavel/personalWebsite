{"version":3,"sources":["ng://ngx-bootstrap/carousel/carousel.config.ts","ng://ngx-bootstrap/carousel/carousel.component.ts","ng://ngx-bootstrap/carousel/slide.component.ts","ng://ngx-bootstrap/carousel/carousel.module.ts"],"names":["CarouselConfig","this","interval","noPause","noWrap","showIndicators","Injectable","UNKNOWN","NEXT","PREV","CarouselComponent","config","ngZone","activeSlideChange","EventEmitter","_slides","LinkedList","destroyed","Object","assign","defineProperty","prototype","_currentActiveSlide","index","length","_select","_interval","value","restartTimer","toArray","isBs3","ngOnDestroy","addSlide","slide","add","activeSlide","play","removeSlide","_this","remIndex","indexOf","nextSlideIndex_1","isLast","remove","setTimeout","currentSlideIndex_1","getCurrentSlideIndex","emit","nextSlide","force","findNextSlideIndex","Direction","previousSlide","selectSlide","isPlaying","pause","resetTimer","findIndex","active","direction","nextSlideIndex","Error","isNaN","currentSlide","get","currentInterval","runOutsideAngular","setInterval","nInterval","run","slides","clearInterval","Component","args","selector","template","NgZone","Input","Output","SlideComponent","carousel","addClass","ngOnInit","host","[attr.aria-hidden]","HostBinding","type","CarouselModule","forRoot","ngModule","providers","NgModule","imports","CommonModule","declarations","exports"],"mappings":"gcAAA,IAAAA,EAAA,WAEA,SAAAA,IAGEC,KAAAC,SAAW,IAGXD,KAAAE,SAAU,EAGVF,KAAAG,QAAS,EAGTH,KAAAI,gBAAiB,EACnB,2BAbCC,EAAAA,aAaDN,EAfA,MC2BEO,QAAA,EACAC,KAAA,EACAC,KAAA,4DAMF,IAAAC,EAAA,WA0DE,SAAAA,EAAYC,EAAgCC,GAAAX,KAAAW,OAAAA,EA5C5CX,KAAAY,kBAA0C,IAAIC,EAAAA,cAAqB,GAoCzDb,KAAAc,QAAsC,IAAIC,EAAAA,WAE1Cf,KAAAgB,WAAY,EAOpBC,OAAOC,OAAOlB,KAAMU,GA0NxB,OApQEO,OAAAE,eACIV,EAAAW,UAAA,cAAW,KAMf,WACE,OAAOpB,KAAKqB,yBARd,SACgBC,GACVtB,KAAKc,QAAQS,QAAUD,IAAUtB,KAAKqB,qBACxCrB,KAAKwB,QAAQF,oCAYjBL,OAAAE,eACIV,EAAAW,UAAA,WAAQ,KADZ,WAEE,OAAOpB,KAAKyB,eAGd,SAAaC,GACX1B,KAAKyB,UAAYC,EACjB1B,KAAK2B,gDAGPV,OAAAE,eAAIV,EAAAW,UAAA,SAAM,KAAV,WACE,OAAOpB,KAAKc,QAAQc,2CAWtBX,OAAAE,eAAIV,EAAAW,UAAA,QAAK,KAAT,WACE,OAAQS,EAAAA,yCAOVpB,EAAAW,UAAAU,YAAA,WACE9B,KAAKgB,WAAY,GAQnBP,EAAAW,UAAAW,SAAA,SAASC,GACPhC,KAAKc,QAAQmB,IAAID,GACW,IAAxBhC,KAAKc,QAAQS,SACfvB,KAAKqB,yBAAsB,EAC3BrB,KAAKkC,YAAc,EACnBlC,KAAKmC,SAST1B,EAAAW,UAAAgB,YAAA,SAAYJ,GAAZ,IAAAK,EAAArC,KACQsC,EAAWtC,KAAKc,QAAQyB,QAAQP,GAEtC,GAAIhC,KAAKqB,sBAAwBiB,EAAU,KAErCE,OAAyB,EACH,EAAtBxC,KAAKc,QAAQS,SAIfiB,EAAkBxC,KAAKyC,OAAOH,GAE1BtC,KAAKG,OAASmC,EAAW,EAAI,EAD7BA,GAGNtC,KAAKc,QAAQ4B,OAAOJ,GAGpBK,WAAW,WACTN,EAAKb,QAAQgB,IACZ,OACE,CACLxC,KAAKc,QAAQ4B,OAAOJ,OACdM,EAAoB5C,KAAK6C,uBAC/BF,WAAW,WAETN,EAAKhB,oBAAsBuB,EAC3BP,EAAKzB,kBAAkBkC,KAAKT,EAAKhB,sBAChC,KAQPZ,EAAAW,UAAA2B,UAAA,SAAUC,QAAA,IAAAA,IAAAA,GAAA,GACRhD,KAAKkC,YAAclC,KAAKiD,mBAAmBC,EAAU3C,KAAMyC,IAO7DvC,EAAAW,UAAA+B,cAAA,SAAcH,QAAA,IAAAA,IAAAA,GAAA,GACZhD,KAAKkC,YAAclC,KAAKiD,mBAAmBC,EAAU1C,KAAMwC,IAO7DvC,EAAAW,UAAAgC,YAAA,SAAY9B,GACVtB,KAAKkC,YAAcZ,GAMrBb,EAAAW,UAAAe,KAAA,WACOnC,KAAKqD,YACRrD,KAAKqD,WAAY,EACjBrD,KAAK2B,iBAOTlB,EAAAW,UAAAkC,MAAA,WACOtD,KAAKE,UACRF,KAAKqD,WAAY,EACjBrD,KAAKuD,eAOT9C,EAAAW,UAAAyB,qBAAA,WACE,OAAO7C,KAAKc,QAAQ0C,UAAU,SAACxB,GAA0B,OAAAA,EAAMyB,UAOjEhD,EAAAW,UAAAqB,OAAA,SAAOnB,GACL,OAAOA,EAAQ,GAAKtB,KAAKc,QAAQS,QAS3Bd,EAAAW,UAAA6B,mBAAR,SAA2BS,EAAsBV,OAC3CW,EAAiB,EAErB,GACGX,IACAhD,KAAKyC,OAAOzC,KAAKkC,cAChBwB,IAAcR,EAAU1C,OACxBR,KAAKG,OAJT,CASA,OAAQuD,GACN,KAAKR,EAAU3C,KAGboD,EAAkB3D,KAAKyC,OAAOzC,KAAKqB,sBAE9B2B,GAAShD,KAAKG,OAASH,KAAKqB,oBAAsB,EADnDrB,KAAKqB,oBAAsB,EAE/B,MACF,KAAK6B,EAAU1C,KAGbmD,EAC6B,EAA3B3D,KAAKqB,oBACDrB,KAAKqB,oBAAsB,GAC1B2B,GAAShD,KAAKG,OACfH,KAAKqB,oBACLrB,KAAKc,QAAQS,OAAS,EAC5B,MACF,QACE,MAAM,IAAIqC,MAAM,qBAGpB,OAAOD,IAODlD,EAAAW,UAAAI,QAAR,SAAgBF,GACd,GAAIuC,MAAMvC,GACRtB,KAAKsD,YADP,KAKMQ,EAAe9D,KAAKc,QAAQiD,IAAI/D,KAAKqB,qBACvCyC,IACFA,EAAaL,QAAS,OAElBV,EAAY/C,KAAKc,QAAQiD,IAAIzC,GAC/ByB,IACF/C,KAAKqB,oBAAsBC,EAC3ByB,EAAUU,QAAS,EACnBzD,KAAKkC,YAAcZ,EACnBtB,KAAKY,kBAAkBkC,KAAKxB,MAOxBb,EAAAW,UAAAO,aAAR,WAAA,IAAAU,EAAArC,KACEA,KAAKuD,iBACCtD,GAAYD,KAAKC,UAClB4D,MAAM5D,IAAwB,EAAXA,IACtBD,KAAKgE,gBAAkBhE,KAAKW,OAAOsD,kBAAkB,WACnD,OAAOC,YAAY,eACXC,GAAa9B,EAAKpC,SACxBoC,EAAK1B,OAAOyD,IAAI,WAEZ/B,EAAKgB,YACJQ,MAAMxB,EAAKpC,WACA,EAAZkE,GACA9B,EAAKgC,OAAO9C,OAEZc,EAAKU,YAELV,EAAKiB,WAGRrD,OAQDQ,EAAAW,UAAAmC,WAAR,WACMvD,KAAKgE,kBACPM,cAActE,KAAKgE,iBACnBhE,KAAKgE,qBAAkB,wBAlR5BO,EAAAA,UAASC,KAAA,CAAC,CACTC,SAAU,WACVC,SAAA,8/BAbO3E,SALyB4E,EAAAA,0CAsB/BC,EAAAA,uBAEAA,EAAAA,8BAEAA,EAAAA,iCAGAC,EAAAA,4BAIAD,EAAAA,wBAeAA,EAAAA,SAqPHnE,EArRA,GCnCAqE,EAAA,WAmCE,SAAAA,EAAYC,GALZ/E,KAAAgF,UAAW,EAMThF,KAAK+E,SAAWA,EAYpB,OARED,EAAA1D,UAAA6D,SAAA,WACEjF,KAAK+E,SAAShD,SAAS/B,OAIzB8E,EAAA1D,UAAAU,YAAA,WACE9B,KAAK+E,SAAS3C,YAAYpC,2BApC7BuE,EAAAA,UAASC,KAAA,CAAC,CACTC,SAAU,QACVC,SAAU,oGAKVQ,KAAM,CACJC,qBAAsB,wDAVjB1E,qCAeN2E,EAAAA,YAAWZ,KAAA,CAAC,iBAAc,CAAAa,KAC1BT,EAAAA,wBAIAQ,EAAAA,YAAWZ,KAAA,CAAC,eAAY,CAAAa,KACxBD,EAAAA,YAAWZ,KAAA,CAAC,0BAmBfM,EAhDA,GCAAQ,EAAA,WAOA,SAAAA,KAUA,OAHSA,EAAAC,QAAP,WACE,MAAO,CAAEC,SAAUF,EAAgBG,UAAW,yBARjDC,EAAAA,SAAQlB,KAAA,CAAC,CACRmB,QAAS,CAACC,EAAAA,cACVC,aAAc,CAACf,EAAgBrE,GAC/BqF,QAAS,CAAChB,EAAgBrE,GAC1BgF,UAAW,CAAC1F,OAMduF,EAjBA","sourcesContent":["import { Injectable } from '@angular/core';\n\n@Injectable()\nexport class CarouselConfig {\n  /** Default interval of auto changing of slides */\n  interval = 5000;\n\n  /** Is loop of auto changing of slides can be paused */\n  noPause = false;\n\n  /** Is slides can wrap from the last to the first slide */\n  noWrap = false;\n\n  /** Show carousel-indicators */\n  showIndicators = true;\n}\n","// tslint:disable:max-file-line-count\n/***\n * pause (not yet supported) (?string='hover') - event group name which pauses\n * the cycling of the carousel, if hover pauses on mouseenter and resumes on\n * mouseleave keyboard (not yet supported) (?boolean=true) - if false\n * carousel will not react to keyboard events\n * note: swiping not yet supported\n */\n/****\n * Problems:\n * 1) if we set an active slide via model changes, .active class remains on a\n * current slide.\n * 2) if we have only one slide, we shouldn't show prev/next nav buttons\n * 3) if first or last slide is active and noWrap is true, there should be\n * \"disabled\" class on the nav buttons.\n * 4) default interval should be equal 5000\n */\n\nimport {\n  Component, EventEmitter, Input, NgZone, OnDestroy, Output\n} from '@angular/core';\n\nimport { isBs3, LinkedList } from 'ngx-bootstrap/utils';\nimport { SlideComponent } from './slide.component';\nimport { CarouselConfig } from './carousel.config';\n\nexport enum Direction {\n  UNKNOWN,\n  NEXT,\n  PREV\n}\n\n/**\n * Base element to create carousel\n */\n@Component({\n  selector: 'carousel',\n  templateUrl: './carousel.component.html'\n})\nexport class CarouselComponent implements OnDestroy {\n  /** If `true` â carousel will not cycle continuously and will have hard stops (prevent looping) */\n  @Input() noWrap: boolean;\n  /**  If `true` â will disable pausing on carousel mouse hover */\n  @Input() noPause: boolean;\n  /**  If `true` â carousel-indicators are visible  */\n  @Input() showIndicators: boolean;\n\n  /** Will be emitted when active slide has been changed. Part of two-way-bindable [(activeSlide)] property */\n  @Output()\n  activeSlideChange: EventEmitter<number> = new EventEmitter<number>(false);\n\n  /** Index of currently displayed slide(started for 0) */\n  @Input()\n  set activeSlide(index: number) {\n    if (this._slides.length && index !== this._currentActiveSlide) {\n      this._select(index);\n    }\n  }\n\n  get activeSlide(): number {\n    return this._currentActiveSlide;\n  }\n\n  /**\n   * Delay of item cycling in milliseconds. If false, carousel won't cycle\n   * automatically.\n   */\n  @Input()\n  get interval(): number {\n    return this._interval;\n  }\n\n  set interval(value: number) {\n    this._interval = value;\n    this.restartTimer();\n  }\n\n  get slides(): SlideComponent[] {\n    return this._slides.toArray();\n  }\n\n  // tslint:disable-next-line:no-any\n  protected currentInterval: any;\n  protected _currentActiveSlide: number;\n  protected _interval: number;\n  protected _slides: LinkedList<SlideComponent> = new LinkedList<SlideComponent>();\n  protected isPlaying: boolean;\n  protected destroyed = false;\n\n  get isBs4(): boolean {\n    return !isBs3();\n  }\n\n  constructor(config: CarouselConfig, private ngZone: NgZone) {\n    Object.assign(this, config);\n  }\n\n  ngOnDestroy(): void {\n    this.destroyed = true;\n  }\n\n  /**\n   * Adds new slide. If this slide is first in collection - set it as active\n   * and starts auto changing\n   * @param slide\n   */\n  addSlide(slide: SlideComponent): void {\n    this._slides.add(slide);\n    if (this._slides.length === 1) {\n      this._currentActiveSlide = void 0;\n      this.activeSlide = 0;\n      this.play();\n    }\n  }\n\n  /**\n   * Removes specified slide. If this slide is active - will roll to another\n   * slide\n   * @param slide\n   */\n  removeSlide(slide: SlideComponent): void {\n    const remIndex = this._slides.indexOf(slide);\n\n    if (this._currentActiveSlide === remIndex) {\n      // removing of active slide\n      let nextSlideIndex: number = void 0;\n      if (this._slides.length > 1) {\n        // if this slide last - will roll to first slide, if noWrap flag is\n        // FALSE or to previous, if noWrap is TRUE in case, if this slide in\n        // middle of collection, index of next slide is same to removed\n        nextSlideIndex = !this.isLast(remIndex)\n          ? remIndex\n          : this.noWrap ? remIndex - 1 : 0;\n      }\n      this._slides.remove(remIndex);\n\n      // prevents exception with changing some value after checking\n      setTimeout(() => {\n        this._select(nextSlideIndex);\n      }, 0);\n    } else {\n      this._slides.remove(remIndex);\n      const currentSlideIndex = this.getCurrentSlideIndex();\n      setTimeout(() => {\n        // after removing, need to actualize index of current active slide\n        this._currentActiveSlide = currentSlideIndex;\n        this.activeSlideChange.emit(this._currentActiveSlide);\n      }, 0);\n    }\n  }\n\n  /**\n   * Rolling to next slide\n   * @param force: {boolean} if true - will ignore noWrap flag\n   */\n  nextSlide(force = false): void {\n    this.activeSlide = this.findNextSlideIndex(Direction.NEXT, force);\n  }\n\n  /**\n   * Rolling to previous slide\n   * @param force: {boolean} if true - will ignore noWrap flag\n   */\n  previousSlide(force = false): void {\n    this.activeSlide = this.findNextSlideIndex(Direction.PREV, force);\n  }\n\n  /**\n   * Rolling to specified slide\n   * @param index: {number} index of slide, which must be shown\n   */\n  selectSlide(index: number): void {\n    this.activeSlide = index;\n  }\n\n  /**\n   * Starts a auto changing of slides\n   */\n  play(): void {\n    if (!this.isPlaying) {\n      this.isPlaying = true;\n      this.restartTimer();\n    }\n  }\n\n  /**\n   * Stops a auto changing of slides\n   */\n  pause(): void {\n    if (!this.noPause) {\n      this.isPlaying = false;\n      this.resetTimer();\n    }\n  }\n\n  /**\n   * Finds and returns index of currently displayed slide\n   */\n  getCurrentSlideIndex(): number {\n    return this._slides.findIndex((slide: SlideComponent) => slide.active);\n  }\n\n  /**\n   * Defines, whether the specified index is last in collection\n   * @param index\n   */\n  isLast(index: number): boolean {\n    return index + 1 >= this._slides.length;\n  }\n\n  /**\n   * Defines next slide index, depending of direction\n   * @param direction: Direction(UNKNOWN|PREV|NEXT)\n   * @param force: {boolean} if TRUE - will ignore noWrap flag, else will\n   *   return undefined if next slide require wrapping\n   */\n  private findNextSlideIndex(direction: Direction, force: boolean): number {\n    let nextSlideIndex = 0;\n\n    if (\n      !force &&\n      (this.isLast(this.activeSlide) &&\n        direction !== Direction.PREV &&\n        this.noWrap)\n    ) {\n      return void 0;\n    }\n\n    switch (direction) {\n      case Direction.NEXT:\n        // if this is last slide, not force, looping is disabled\n        // and need to going forward - select current slide, as a next\n        nextSlideIndex = !this.isLast(this._currentActiveSlide)\n          ? this._currentActiveSlide + 1\n          : !force && this.noWrap ? this._currentActiveSlide : 0;\n        break;\n      case Direction.PREV:\n        // if this is first slide, not force, looping is disabled\n        // and need to going backward - select current slide, as a next\n        nextSlideIndex =\n          this._currentActiveSlide > 0\n            ? this._currentActiveSlide - 1\n            : !force && this.noWrap\n            ? this._currentActiveSlide\n            : this._slides.length - 1;\n        break;\n      default:\n        throw new Error('Unknown direction');\n    }\n\n    return nextSlideIndex;\n  }\n\n  /**\n   * Sets a slide, which specified through index, as active\n   * @param index\n   */\n  private _select(index: number): void {\n    if (isNaN(index)) {\n      this.pause();\n\n      return;\n    }\n    const currentSlide = this._slides.get(this._currentActiveSlide);\n    if (currentSlide) {\n      currentSlide.active = false;\n    }\n    const nextSlide = this._slides.get(index);\n    if (nextSlide) {\n      this._currentActiveSlide = index;\n      nextSlide.active = true;\n      this.activeSlide = index;\n      this.activeSlideChange.emit(index);\n    }\n  }\n\n  /**\n   * Starts loop of auto changing of slides\n   */\n  private restartTimer() {\n    this.resetTimer();\n    const interval = +this.interval;\n    if (!isNaN(interval) && interval > 0) {\n      this.currentInterval = this.ngZone.runOutsideAngular(() => {\n        return setInterval(() => {\n          const nInterval = +this.interval;\n          this.ngZone.run(() => {\n            if (\n              this.isPlaying &&\n              !isNaN(this.interval) &&\n              nInterval > 0 &&\n              this.slides.length\n            ) {\n              this.nextSlide();\n            } else {\n              this.pause();\n            }\n          });\n        }, interval);\n      });\n    }\n  }\n\n  /**\n   * Stops loop of auto changing of slides\n   */\n  private resetTimer(): void {\n    if (this.currentInterval) {\n      clearInterval(this.currentInterval);\n      this.currentInterval = void 0;\n    }\n  }\n}\n","import {\n  Component,\n  HostBinding,\n  OnDestroy,\n  Input,\n  OnInit\n} from '@angular/core';\n\nimport { CarouselComponent } from './carousel.component';\n\n@Component({\n  selector: 'slide',\n  template: `\n    <div [class.active]=\"active\" class=\"item\">\n      <ng-content></ng-content>\n    </div>\n  `,\n  host: {\n    '[attr.aria-hidden]': '!active'\n  }\n})\nexport class SlideComponent implements OnInit, OnDestroy {\n  /** Is current slide active */\n  @HostBinding('class.active')\n  @Input()\n  active: boolean;\n\n  /** Wraps element by appropriate CSS classes */\n  @HostBinding('class.item')\n  @HostBinding('class.carousel-item')\n  addClass = true;\n\n  /** Link to Parent(container-collection) component */\n  protected carousel: CarouselComponent;\n\n  constructor(carousel: CarouselComponent) {\n    this.carousel = carousel;\n  }\n\n  /** Fires changes in container collection after adding a new slide instance */\n  ngOnInit(): void {\n    this.carousel.addSlide(this);\n  }\n\n  /** Fires changes in container collection after removing of this slide instance */\n  ngOnDestroy(): void {\n    this.carousel.removeSlide(this);\n  }\n}\n","import { CommonModule } from '@angular/common';\nimport { NgModule, ModuleWithProviders } from '@angular/core';\n\nimport { CarouselComponent } from './carousel.component';\nimport { SlideComponent } from './slide.component';\nimport { CarouselConfig } from './carousel.config';\n\n@NgModule({\n  imports: [CommonModule],\n  declarations: [SlideComponent, CarouselComponent],\n  exports: [SlideComponent, CarouselComponent],\n  providers: [CarouselConfig]\n})\nexport class CarouselModule {\n  static forRoot(): ModuleWithProviders {\n    return { ngModule: CarouselModule, providers: [] };\n  }\n}\n"]}